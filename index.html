<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MindReader V31</title>
    <style>
        /* --- V30 视觉保留 --- */
        :root {
            --bg: #000000;
            --glass: rgba(20, 20, 20, 0.95);
            --border: rgba(255, 255, 255, 0.2);
            --accent: #00f2ff; 
            --warn: #ffcc00;
            --danger: #ff2a6d; 
            --text: #ffffff;
        }
        body { background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; margin: 0; height: 100dvh; display: flex; flex-direction: column; overflow: hidden; }
        .app { flex: 1; display: flex; flex-direction: column; position: relative; width: 100%; height: 100%; }
        
        /* HUD */
        .hud {
            background: var(--glass); border-bottom: 1px solid var(--border);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px 20px 0 20px; z-index: 50; flex-shrink: 0; position: relative;
        }
        .phase-badge {
            font-size: 11px; font-weight: 800; letter-spacing: 2px; padding: 4px 8px;
            border-radius: 4px; margin-bottom: 10px; text-transform: uppercase; border: 1px solid currentColor;
            color: var(--accent);
        }
        .q-text { 
            font-size: 18px; font-weight: 700; text-align: center; line-height: 1.4; max-width: 600px;
            color: #ffffff !important; text-shadow: 0 2px 4px rgba(0,0,0,0.5); margin-bottom: 15px; 
        }
        .progress-track { width: 100%; height: 4px; background: rgba(255,255,255,0.1); margin-top: 10px; }
        .progress-fill { height: 100%; width: 0%; background: var(--accent); box-shadow: 0 0 10px currentColor; transition: width 0.1s linear; }

        /* Viewport */
        .viewport { flex: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        #main_canvas { width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); }

        /* Dashboard */
        .dashboard {
            height: 120px; background: var(--glass); border-top: 1px solid var(--border);
            display: flex; gap: 10px; padding: 15px; flex-shrink: 0; overflow-x: auto;
            padding-bottom: calc(15px + env(safe-area-inset-bottom));
        }
        .dash-card { flex: 1; min-width: 90px; background: rgba(255,255,255,0.05); border: 1px solid var(--border); border-radius: 8px; position: relative; overflow: hidden; }
        .dash-label { position: absolute; top: 5px; left: 5px; font-size: 9px; color: rgba(255,255,255,0.7); font-weight: 700; }
        .mini-canvas { width: 100%; height: 100%; opacity: 0.8; }

        /* Layers */
        .layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 0.3s; padding: 30px; box-sizing: border-box;
        }
        .layer.hidden { opacity: 0; pointer-events: none; }
        .guide-box { background: #111; border: 1px solid #333; border-radius: 20px; padding: 30px; max-width: 400px; width: 100%; text-align: center; }
        .btn-main {
            margin-top: 25px; width: 100%; padding: 18px 0; border-radius: 12px; border: none;
            background: linear-gradient(135deg, var(--accent), #0044ff); color: #ffffff !important;
            font-size: 16px; font-weight: 700; cursor: pointer;
        }
        
        /* Report */
        .report-box { width: 100%; height: 100%; overflow-y: auto; padding: 20px; background: #050505; box-sizing: border-box; }
        .evidence-row { display: flex; gap: 10px; margin-bottom: 30px; margin-top: 10px; }
        .photo-card { flex: 1; background: #111; border: 1px solid #333; border-radius: 8px; overflow: hidden; }
        .photo-img { width: 100%; height: auto; display: block; border-bottom: 1px solid #333; }
        .photo-meta { padding: 10px; font-size: 10px; text-align: center; color: #aaa; text-transform: uppercase; font-weight: 700; }
        .log-item { background: #111; padding: 15px; border-radius: 10px; margin-bottom: 12px; border: 1px solid #333; }
        .log-item.stress { border-left: 4px solid var(--warn); }
        .log-item.trap { border-left: 4px solid var(--danger); }
        .log-item.baseline { border-left: 4px solid var(--accent); }
        .log-title { font-size: 10px; margin-bottom: 5px; text-transform: uppercase; font-weight: 700; }

        #src_video { display: none; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>

<div class="layer" id="layer_start">
    <div class="guide-box">
        <h1 style="margin:0 0 10px 0; font-size: 26px; color:#fff;">MindReader <span style="font-size:16px; color:#666;">V31</span></h1>
        <p style="color:#888; font-size:13px; margin-bottom:30px">Bare Metal Edition</p>
        <button class="btn-main" id="btn_start" onclick="unlockSystem()">立即启动 (防卡死)</button>
    </div>
</div>

<div class="app">
    <div class="hud" id="hud_box">
        <div class="phase-badge" id="hud_badge" style="color:var(--accent); border-color:var(--accent)">SYSTEM READY</div>
        <div class="q-text" id="hud_text">初始化传感器...</div>
        <div class="progress-track"><div class="progress-fill" id="hud_bar"></div></div>
    </div>
    <div class="viewport"><canvas id="main_canvas"></canvas></div>
    <div class="dashboard">
        <div class="dash-card"><div class="dash-label">FACE</div><canvas id="cv_face" class="mini-canvas"></canvas></div>
        <div class="dash-card"><div class="dash-label">POSE</div><canvas id="cv_pose" class="mini-canvas"></canvas></div>
        <div class="dash-card"><div class="dash-label">HANDS</div><canvas id="cv_hands" class="mini-canvas"></canvas></div>
    </div>
</div>

<div class="layer hidden" id="layer_report">
    <div class="report-box">
        <h2 style="text-align:center; color:#fff; margin-bottom:30px">心理档案</h2>
        <div style="font-size:11px; color:#888; font-weight:bold">证据快照</div>
        <div class="evidence-row" id="evidence_area"></div>
        <div style="font-size:11px; color:#888; font-weight:bold">动态流水</div>
        <div id="log_area" style="margin-top:10px"></div>
        <button class="btn-main" style="background:#222; margin-top:30px" onclick="location.reload()">归档重置</button>
    </div>
</div>

<video id="src_video" playsinline webkit-playsinline muted autoplay></video>

<script>
    // --- 题库 ---
    const RAW_POOL_BASE = ["简单介绍一下你的爱好？", "你最喜欢的季节是哪个？", "平时周末几点起床？", "养过宠物吗？"];
    const RAW_POOL_STRESS_1 = ["【高压】看着我。你最近撒过谎吗？", "【高压】如果查你手机相册，会有见不得人的东西吗？"];
    const RAW_POOL_STRESS_2 = ["【两难】必须在事业和家庭牺牲一个，选哪个？", "【审讯】你是否背叛过信任你的人？"];
    const RAW_POOL_TRAP = ["【追问】你在撒谎吗？为什么眼神躲避？", "【追问】你的动作出卖了你，在紧张什么？"];

    let POOL_BASE=[], POOL_STRESS_1=[], POOL_STRESS_2=[], POOL_TRAP=[];
    function shuffle(a){let c=a.length,r;while(c!=0){r=Math.floor(Math.random()*c);c--;[a[c],a[r]]=[a[r],a[c]];}return a;}

    let sessionLog = [];
    let currentStep = 0; 
    let currentQ = null;
    let evidence = { baseline: null, anomaly: null, maxScore: 0, frozenEyeBase: 0 };
    
    let stats = { 
        blinks: 0, blinkStorms: 0, baseEyeH: 0, baseLipH: 0,
        noseTouch: 0, chinTouch: 0, neckTouch: 0, lipCompress: 0, contemptFrames: 0,
        rubFrames: 0, steepFrames: 0, crossFrames: 0, 
        ventralDenial: 0, freezeFrames: 0, shrugFrames: 0, shockFrames: 0, shockDuration: 0,
        frames: 0, lastEyeOpen: true, lastThumbPos: null, blinkBuffer: []
    };

    // --- 手动帧循环 (Anti-Freeze Core) ---
    let holistic;
    let videoElement;
    let canvasElement;
    let canvasCtx;
    let isRunning = false;

    async function unlockSystem() {
        document.getElementById('layer_start').classList.add('hidden');
        POOL_BASE = shuffle([...RAW_POOL_BASE]);
        POOL_STRESS_1 = shuffle([...RAW_POOL_STRESS_1]);
        POOL_STRESS_2 = shuffle([...RAW_POOL_STRESS_2]);
        POOL_TRAP = shuffle([...RAW_POOL_TRAP]);

        videoElement = document.getElementById('src_video');
        canvasElement = document.getElementById('main_canvas');
        canvasCtx = canvasElement.getContext('2d');

        try {
            // 最保守的请求，防止浏览器拒绝
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                initAI(); // 视频准备好后再加载AI
            };
        } catch (e) {
            alert("摄像头失败: " + e.message);
        }
    }

    async function initAI() {
        if (typeof Holistic === 'undefined') { alert("AI库未加载，请检查网络"); return; }
        
        holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({modelComplexity: 1, minDetectionConfidence: 0.5, refineFaceLandmarks: true});
        holistic.onResults(onResults);
        
        isRunning = true;
        processVideo(); // 手动启动循环
        setTimeout(() => runStep(0), 1000);
    }

    // --- 核心：手动驱动每一帧，取代 Camera Utils ---
    async function processVideo() {
        if (!isRunning) return;
        
        if (videoElement.readyState >= 2) { // HAVE_CURRENT_DATA
            // 只有当尺寸不对时才调整 Canvas
            if (canvasElement.width !== videoElement.videoWidth) {
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
            }
            await holistic.send({image: videoElement});
        }
        requestAnimationFrame(processVideo);
    }

    // --- 业务逻辑 ---
    function runStep(stepIndex) {
        currentStep = stepIndex;
        const oldEyeBase = stats.baseEyeH;
        const oldLipBase = stats.baseLipH;
        stats = { 
            blinks: 0, blinkStorms: 0, baseEyeH: oldEyeBase, baseLipH: oldLipBase,
            noseTouch: 0, chinTouch: 0, neckTouch: 0, lipCompress: 0, contemptFrames: 0,
            rubFrames: 0, steepFrames: 0, crossFrames: 0, ventralDenial: 0, freezeFrames: 0, shrugFrames: 0,
            shockFrames: 0, shockDuration: 0, frames: 0, lastEyeOpen: true, lastThumbPos: null, blinkBuffer: []
        };

        if (stepIndex === 0) currentQ = { type: 'baseline', time: 8, text: POOL_BASE[0], id: 1 };
        else if (stepIndex === 1) currentQ = { type: 'baseline', time: 8, text: POOL_BASE[1], id: 2 };
        else if (stepIndex === 2) {
            if (!evidence.baseline) captureEvidence('baseline');
            evidence.frozenEyeBase = stats.baseEyeH;
            currentQ = { type: 'stress', time: 10, text: POOL_STRESS_1[0], id: 3 };
        } else if (stepIndex === 3) {
            const prevLog = sessionLog[2];
            currentQ = (prevLog && prevLog.score > 20) ? { type: 'trap', time: 10, text: POOL_TRAP[0], id: 4 } : { type: 'stress', time: 10, text: POOL_STRESS_2[0], id: 4 };
        } else if (stepIndex === 4) {
            const prevLog = sessionLog[3];
            if (prevLog.q.type === 'stress' && prevLog.score > 20) {
                currentQ = { type: 'trap', time: 10, text: "【最终追问】你的反应很剧烈，请解释。", id: 5 };
            } else { generateReport(); return; }
        } else { generateReport(); return; }

        updateHUD();
        setTimeout(() => { finishQuestion(); runStep(stepIndex + 1); }, currentQ.time * 1000);
    }

    function updateHUD() {
        const badge = document.getElementById('hud_badge');
        const bar = document.getElementById('hud_bar');
        
        let color = '#00f2ff';
        if (currentQ.type === 'stress') color = '#ffcc00';
        if (currentQ.type === 'trap') color = '#ff2a6d';

        badge.innerText = `${currentQ.type.toUpperCase()} PHASE`;
        badge.style.color = color;
        badge.style.borderColor = color;
        document.getElementById('hud_text').innerText = currentQ.text;
        
        bar.style.transition = 'none'; bar.style.width = '0%'; bar.style.backgroundColor = color;
        requestAnimationFrame(() => { requestAnimationFrame(() => { bar.style.transition = `width ${currentQ.time}s linear`; bar.style.width = '100%'; }); });
    }

    function finishQuestion() {
        const cpm = Math.round(stats.blinks / (currentQ.time / 60));
        let score = 0;
        if (currentQ.type !== 'baseline') {
            const baseLogs = sessionLog.filter(l => l.q.type === 'baseline');
            const baseCPM = baseLogs.length ? baseLogs[0].cpm : 20;
            if (cpm > baseCPM * 1.4) score += 10;
            if (stats.blinkStorms > 0) score += 15;
            if (stats.noseTouch > 5) score += 10;
            if (stats.neckTouch > 5) score += 10;
            if (stats.lipCompress > 10) score += 8;
            if (stats.rubFrames > 20) score += 10;
            if (stats.shockFrames > 0 && stats.shockDuration > 30) score += 10;
        }
        sessionLog.push({ q: currentQ, stats: stats, cpm: cpm, score: score });
    }

    function captureEvidence(type) {
        if(canvasElement.width > 0) evidence[type] = canvasElement.toDataURL('image/jpeg', 0.8);
    }

    // --- 绘制 & 逻辑 ---
    const sideCtx = {
        face: document.getElementById('cv_face').getContext('2d'),
        pose: document.getElementById('cv_pose').getContext('2d'),
        hands: document.getElementById('cv_hands').getContext('2d')
    };

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        if (results.faceLandmarks) {
            drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {color: '#ffffff11', lineWidth: 0.5});
            
            // 逻辑计算
            const face = results.faceLandmarks;
            const noseTip = face[1];
            const leftEyeH = Math.abs(face[159].y - face[145].y);
            const lipH = Math.abs(face[13].y - face[14].y);

            // 基准
            if (currentQ && currentQ.type === 'baseline') {
                stats.baseEyeH = (stats.baseEyeH * stats.frames + leftEyeH) / (stats.frames + 1);
                stats.baseLipH = (stats.baseLipH * stats.frames + lipH) / (stats.frames + 1);
            }

            // 1. 眼睛
            if (currentQ) {
                const isClosed = leftEyeH < 0.012;
                if (isClosed && stats.lastEyeOpen) {
                    stats.blinks++;
                    const now = Date.now();
                    stats.blinkBuffer.push(now);
                    stats.blinkBuffer = stats.blinkBuffer.filter(t => now - t < 500);
                    if (stats.blinkBuffer.length > 3) stats.blinkStorms++;
                }
                stats.lastEyeOpen = !isClosed;
            }

            // 2. 表情
            if (currentQ && currentQ.type !== 'baseline') {
                if (evidence.frozenEyeBase > 0 && leftEyeH > evidence.frozenEyeBase * 1.4) {
                    stats.shockFrames++; stats.shockDuration++;
                } else { stats.shockDuration = 0; }
                
                if (stats.baseLipH > 0 && lipH < stats.baseLipH * 0.6) stats.lipCompress++;
            }

            // 3. 手部
            const checkHand = (hand) => {
                if (!hand) return;
                const idx = hand[8]; const thumb = hand[4];
                // 摸鼻
                if (Math.sqrt(Math.pow(idx.x - noseTip.x, 2) + Math.pow(idx.y - noseTip.y, 2)) < 0.05) {
                    stats.noseTouch++;
                    canvasCtx.beginPath(); canvasCtx.arc(noseTip.x*canvasElement.width, noseTip.y*canvasElement.height, 20, 0, 2*Math.PI);
                    canvasCtx.strokeStyle = '#ff2a6d'; canvasCtx.lineWidth = 3; canvasCtx.stroke();
                }
                // 搓手
                if (Math.sqrt(Math.pow(thumb.x - idx.x, 2) + Math.pow(thumb.y - idx.y, 2)) < 0.04) {
                    if (stats.lastThumbPos) {
                        const move = Math.sqrt(Math.pow(thumb.x - stats.lastThumbPos.x, 2) + Math.pow(thumb.y - stats.lastThumbPos.y, 2));
                        if (move > 0.003) stats.rubFrames++;
                    }
                    stats.lastThumbPos = {x: thumb.x, y: thumb.y};
                }
            };
            if (results.leftHandLandmarks) checkHand(results.leftHandLandmarks);
            if (results.rightHandLandmarks) checkHand(results.rightHandLandmarks);
            
            // 抓拍
            if (currentQ && (currentQ.type === 'stress' || currentQ.type === 'trap')) {
                // 简单异常分计算
                let currentScore = 0;
                if(stats.noseTouch > 0) currentScore += 5;
                if(stats.blinkStorms > 0) currentScore += 5;
                if(currentScore > evidence.maxScore) {
                    evidence.maxScore = currentScore;
                    captureEvidence('anomaly');
                }
            }
        }

        canvasCtx.restore();
        
        // 侧边栏预览
        drawSide(sideCtx.face, results.faceLandmarks, FACEMESH_TESSELATION, '#00f2ff');
        drawSide(sideCtx.pose, results.poseLandmarks, POSE_CONNECTIONS, '#fff');
        drawSide(sideCtx.hands, results.leftHandLandmarks || results.rightHandLandmarks, HAND_CONNECTIONS, '#ff2a6d');

        if(currentQ) stats.frames++;
    }

    function drawSide(c, data, conn, color) {
        c.canvas.width=150; c.canvas.height=150; c.clearRect(0,0,150,150);
        if(data) { c.save(); drawConnectors(c, data, conn, {color: color, lineWidth: 2}); c.restore(); }
    }

    function generateReport() {
        document.getElementById('layer_report').classList.remove('hidden');
        isRunning = false; // 停止循环
        
        const evArea = document.getElementById('evidence_area');
        const imgBase = evidence.baseline || "";
        const imgAnom = evidence.anomaly || imgBase;
        evArea.innerHTML = `
            <div class="photo-card"><img src="${imgBase}" class="photo-img"><div class="photo-meta" style="color:var(--accent)">基准状态</div></div>
            <div class="photo-card" style="border-color:var(--danger)"><img src="${imgAnom}" class="photo-img"><div class="photo-meta" style="color:var(--danger)">压力反应</div></div>
        `;

        const logArea = document.getElementById('log_area');
        let html = "";
        
        sessionLog.forEach(d => {
            let signals = [];
            if (d.q.type !== 'baseline') {
                const baseLogs = sessionLog.filter(l => l.q.type === 'baseline');
                const baseCPM = baseLogs.length ? baseLogs[0].cpm : 20;
                if (d.cpm > baseCPM * 1.4) signals.push(`眨眼激增(${d.cpm})`);
                if (d.stats.blinkStorms > 0) signals.push("眨眼风暴");
                if (d.stats.lipCompress > 15) signals.push("抿嘴掩饰");
                if (d.stats.noseTouch > 5) signals.push("触碰鼻尖");
                if (d.stats.rubFrames > 20) signals.push("焦虑搓手");
                if (d.stats.shockFrames > 0 && d.stats.shockDuration > 30) signals.push("假惊讶");
            }
            const isRisk = signals.length > 0;
            let titleColor = '#00f2ff';
            if(d.q.type === 'stress') titleColor = '#ffcc00';
            if(d.q.type === 'trap') titleColor = '#ff2a6d';

            html += `
                <div class="log-item ${d.q.type}">
                    <div class="log-title" style="color:${titleColor}">${d.q.type.toUpperCase()} PHASE</div>
                    <div style="font-size:16px; color:#fff; font-weight:700; margin-bottom:8px">"${d.q.text}"</div>
                    ${isRisk ? `<div style="color:#ff8a84; font-size:12px; font-weight:bold">⚠ ${signals.join(", ")}</div>` : '<div style="font-size:12px; color:#aaa">反应平稳</div>'}
                </div>
            `;
        });
        logArea.innerHTML = html;
    }
</script>
</body>
</html>
