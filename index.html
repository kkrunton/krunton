<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MindReader V27</title>
    <style>
        /* --- è§†è§‰ç³»ç»Ÿ (V26 ç¨³å®šç‰ˆ) --- */
        :root {
            --bg: #000000;
            --glass: rgba(20, 20, 20, 0.95);
            --border: rgba(255, 255, 255, 0.2);
            --accent: #00f2ff;Â 
            --warn: #ffcc00;
            --danger: #ff2a6d;Â 
            --text: #ffffff;
        }

        body {
            background: var(--bg); color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", monospace;
            margin: 0; height: 100dvh; display: flex; flex-direction: column; overflow: hidden;
        }

        .app { flex: 1; display: flex; flex-direction: column; position: relative; width: 100%; height: 100%; }

        /* HUD */
        .hud {
            /* ç‰©ç†å ä½ï¼Œé˜²æ­¢é®æŒ¡ */
            background: var(--glass); border-bottom: 1px solid var(--border);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px 20px 15px 20px;Â 
            z-index: 50; flex-shrink: 0; position: relative; backdrop-filter: blur(20px);
        }
        .phase-badge {
            font-size: 11px; font-weight: 800; letter-spacing: 2px; padding: 4px 8px;
            border-radius: 4px; margin-bottom: 10px; text-transform: uppercase; border: 1px solid currentColor;
        }
        .q-text {Â 
            font-size: 18px; font-weight: 700; text-align: center; line-height: 1.4; max-width: 600px;
            color: #ffffff !important;Â 
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 15px;Â 
        }
       Â 
        /* è¿›åº¦æ¡ (ç‰©ç†é•¶åµŒ) */
        .progress-track {
            width: 100%; max-width: 300px; height: 6px;Â 
            background: rgba(255,255,255,0.1);Â 
            border-radius: 3px; overflow: hidden;
        }
        .progress-fill {
            height: 100%; width: 0%;Â 
            background: var(--accent);Â 
            box-shadow: 0 0 15px currentColor;
            transition: width 0.1s linear;Â 
        }

        /* ç›‘æ§åŒº */
        .viewport {
            flex: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; overflow: hidden;
        }
        #main_canvas {
            width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1);
        }

        /* å¼¹çª—å·²ç‰©ç†åˆ é™¤ */

        /* åº•éƒ¨ä»ªè¡¨ç›˜ */
        .dashboard {
            height: 120px; background: var(--glass); border-top: 1px solid var(--border);
            display: flex; gap: 10px; padding: 15px; flex-shrink: 0; overflow-x: auto;
            backdrop-filter: blur(20px); padding-bottom: calc(15px + env(safe-area-inset-bottom));
        }
        .dash-card {
            flex: 1; min-width: 90px; background: rgba(255,255,255,0.05); border: 1px solid var(--border);
            border-radius: 8px; position: relative; overflow: hidden;
        }
        .dash-label { position: absolute; top: 5px; left: 5px; font-size: 9px; color: rgba(255,255,255,0.7); font-weight: 700; }
        .mini-canvas { width: 100%; height: 100%; opacity: 0.8; }

        /* å¯åŠ¨/æŠ¥å‘Šå±‚ */
        .layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 0.3s; padding: 30px; box-sizing: border-box;
        }
        .layer.hidden { opacity: 0; pointer-events: none; }

        .guide-box {
            background: #111; border: 1px solid #333; border-radius: 20px; padding: 30px;
            max-width: 400px; width: 100%; text-align: center;
        }
        .guide-item {
            display: flex; align-items: center; text-align: left; margin: 15px 0; font-size: 13px; color: #ccc;
            background: #222; padding: 15px; border-radius: 10px; border: 1px solid #333;
        }
        .guide-emoji { font-size: 24px; margin-right: 15px; width: 30px; text-align: center; }

        .btn-main {
            margin-top: 25px; width: 100%; padding: 18px 0; border-radius: 12px; border: none;
            background: linear-gradient(135deg, var(--accent), #0044ff); color: #ffffff !important;
            font-size: 16px; font-weight: 700; cursor: pointer; box-shadow: 0 4px 20px rgba(0, 242, 255, 0.3);
        }

        /* æŠ¥å‘Šé¡µ */
        .report-box { width: 100%; height: 100%; overflow-y: auto; padding: 20px; box-sizing: border-box; background: #050505; }
        .evidence-row { display: flex; gap: 10px; margin-bottom: 30px; margin-top: 10px; }
        .photo-card { flex: 1; background: #111; border: 1px solid #333; border-radius: 8px; overflow: hidden; }
        .photo-img { width: 100%; height: auto; display: block; border-bottom: 1px solid #333; }
        .photo-meta { padding: 10px; font-size: 10px; text-align: center; color: #aaa; text-transform: uppercase; font-weight: 700; }
       Â 
        .log-item {
            background: #111; padding: 15px; border-radius: 10px; margin-bottom: 12px; border: 1px solid #333;
        }
        .log-item.stress { border-left: 4px solid var(--danger); }
        .log-item.trap { border-left: 4px solid var(--warn); }
        .log-item.baseline { border-left: 4px solid var(--accent); }

        .log-title { font-size: 10px; margin-bottom: 5px; text-transform: uppercase; font-weight: 700; }
        .log-item.baseline .log-title { color: var(--accent); }
        .log-item.stress .log-title { color: var(--warn); }Â 
        .log-item.trap .log-title { color: var(--danger); }

        #src_video { display: none; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>

<div class="layer" id="layer_start">
    <div class="guide-box">
        <h1 style="margin:0 0 10px 0; font-size: 26px; color:#fff;">MindReader <span style="font-size:16px; color:#666;">V27</span></h1>
        <p style="color:#888; font-size:13px; margin-bottom:30px">Deep Psychology Edition</p>
       Â 
        <div class="guide-item">
            <div class="guide-emoji">ğŸ§ </div>
            <div>
                <div style="color:#fff; font-weight:700">æ·±åº¦ä¾§å†™</div>
                <div>å«è½»è”‘ã€çœŸå‡æƒŠè®¶ã€å¡”å°–æ‰‹åŠ¿ç­‰ 10+ ç§åˆ¤å®š</div>
            </div>
        </div>
        <div class="guide-item">
            <div class="guide-emoji">ğŸ”„</div>
            <div>
                <div style="color:#fff; font-weight:700">åŠ¨æ€åšå¼ˆ</div>
                <div>å¦‚æœæ£€æµ‹åˆ°å¼‚å¸¸ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨å‘èµ·è¿½é—®</div>
            </div>
        </div>
        <div class="guide-item">
            <div class="guide-emoji">ğŸ“</div>
            <div>
                <div style="color:#fff; font-weight:700">æ‘†æ”¾å»ºè®®</div>
                <div>è¯·å°†æ‰‹æœºæ”¾è¿œ (50cm+)ï¼Œç¡®ä¿ä¸ŠåŠèº«å…¥é•œ</div>
            </div>
        </div>

        <button class="btn-main" onclick="startSystem()">å¯åŠ¨åˆ†æ</button>
    </div>
</div>

<div class="app">
    <div class="hud" id="hud_box">
        <div class="phase-badge" id="hud_badge" style="color:var(--accent); border-color:var(--accent)">SYSTEM READY</div>
        <div class="q-text" id="hud_text">ä¼ æ„Ÿå™¨æ ¡å‡†ä¸­...</div>
        <div class="progress-track">
            <div class="progress-fill" id="hud_bar"></div>
        </div>
    </div>

    <div class="viewport">
        <canvas id="main_canvas"></canvas>
    </div>

    <div class="dashboard">
        <div class="dash-card"><div class="dash-label">FACE MESH</div><canvas id="cv_face" class="mini-canvas"></canvas></div>
        <div class="dash-card"><div class="dash-label">SKELETON</div><canvas id="cv_pose" class="mini-canvas"></canvas></div>
        <div class="dash-card"><div class="dash-label">HANDS</div><canvas id="cv_hands" class="mini-canvas"></canvas></div>
    </div>
</div>

<div class="layer hidden" id="layer_report">
    <div class="report-box">
        <h2 style="text-align:center; color:#fff; margin-bottom:30px">æœ€ç»ˆå¿ƒç†æ¡£æ¡ˆ</h2>
       Â 
        <div style="font-size:11px; color:#888; font-weight:bold; letter-spacing:1px">å…³é”®è¯æ®å¿«ç…§ (EVIDENCE)</div>
        <div class="evidence-row" id="evidence_area"></div>

        <div style="font-size:11px; color:#888; font-weight:bold; letter-spacing:1px; margin-top:20px">åŠ¨æ€åˆ†ææµæ°´ (LOG)</div>
        <div id="log_area" style="margin-top:10px"></div>

        <button class="btn-main" style="width:100%; background:#222; margin-top:30px; border:1px solid #444" onclick="location.reload()">å½’æ¡£å¹¶é‡ç½®</button>
    </div>
</div>

<video id="src_video" playsinline></video>

<script>
    // --- é¢˜åº“ (æ´—ç‰Œ) ---
    const RAW_POOL_BASE = ["è¯·çœ‹ç€é•œå¤´ï¼Œç®€å•ä»‹ç»ä¸€ä¸‹ä½ çš„çˆ±å¥½ï¼Ÿ", "ä½ æœ€å–œæ¬¢çš„å­£èŠ‚æ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ", "ä½ å¹³æ—¶å‘¨æœ«ä¸€èˆ¬å‡ ç‚¹èµ·åºŠï¼Ÿ", "ä½ å…»è¿‡å® ç‰©å—ï¼Ÿ"];
    const RAW_POOL_STRESS_1 = ["ã€é«˜å‹ã€‘çœ‹ç€æˆ‘ã€‚ä½ æœ€è¿‘æ˜¯å¦å¯¹èº«è¾¹çš„äººæ’’è¿‡è°ï¼Ÿ", "ã€é«˜å‹ã€‘å¦‚æœæŸ¥ä½ çš„æ‰‹æœºç›¸å†Œï¼Œä¼šæœ‰ä¸æƒ³è®©äººçœ‹çš„ä¸œè¥¿å—ï¼Ÿ"];
    const RAW_POOL_STRESS_2 = ["ã€ä¸¤éš¾ã€‘å¦‚æœå¿…é¡»åœ¨äº‹ä¸šå’Œå®¶åº­ä¸­ç‰ºç‰²ä¸€ä¸ªï¼Œä½ é€‰å“ªä¸ªï¼Ÿ", "ã€å®¡è®¯ã€‘ä½ æ˜¯å¦æ›¾ç»èƒŒå›è¿‡æå…¶ä¿¡ä»»ä½ çš„äººï¼Ÿ"];
    const RAW_POOL_TRAP = ["ã€è¿½é—®ã€‘ä½ åœ¨æ’’è°å—ï¼Ÿä¸ºä»€ä¹ˆä½ åˆšæ‰çš„çœ¼ç¥åœ¨èº²é¿ï¼Ÿ", "ã€è¿½é—®ã€‘ä½ çš„èº«ä½“åŠ¨ä½œå‡ºå–äº†ä½ ï¼Œä½ åœ¨ç´§å¼ ä»€ä¹ˆï¼Ÿ"];

    let POOL_BASE = [], POOL_STRESS_1 = [], POOL_STRESS_2 = [], POOL_TRAP = [];

    function shuffle(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }

    let sessionLog = [];
    let currentStep = 0;Â 
    let currentQ = null;
    let evidence = { baseline: null, anomaly: null, maxScore: 0, frozenEyeBase: 0 };
   Â 
    // --- æ‰©å±•ç»Ÿè®¡å˜é‡ (æ”¯æŒæ‰€æœ‰ 10 ç§é€»è¾‘) ---
    let stats = {Â 
        blinks: 0, blinkStorms: 0, // çœ¨çœ¼é£æš´
        baseEyeH: 0, baseLipH: 0,Â 
       Â 
        noseTouch: 0, chinTouch: 0, neckTouch: 0,
        lipCompress: 0,Â 
        contemptFrames: 0, // è½»è”‘
       Â 
        rubFrames: 0, steepFrames: 0, // æ“æ‰‹ï¼Œå¡”å°–
       Â 
        crossFrames: 0, ventralDenial: 0, freezeFrames: 0, shrugFrames: 0, // å§¿æ€
        shockFrames: 0, shockDuration: 0, // çœŸå‡æƒŠè®¶
       Â 
        frames: 0, lastEyeOpen: true, lastThumbPos: null, lastBlinkTime: 0, blinkBuffer: []
    };

    async function startSystem() {
        POOL_BASE = shuffle([...RAW_POOL_BASE]);
        POOL_STRESS_1 = shuffle([...RAW_POOL_STRESS_1]);
        POOL_STRESS_2 = shuffle([...RAW_POOL_STRESS_2]);
        POOL_TRAP = shuffle([...RAW_POOL_TRAP]);

        document.getElementById('layer_start').classList.add('hidden');
        const video = document.getElementById('src_video');
        try {
            const stream = await navigator.mediaDevices.getUserMedia({Â 
                video: { width: 640, height: 480, facingMode: "user" }Â 
            });
            video.srcObject = stream;
            await video.play();

            const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
            holistic.setOptions({modelComplexity: 1, minDetectionConfidence: 0.5, refineFaceLandmarks: true});
            holistic.onResults(onResults);
           Â 
            const camera = new Camera(video, {
                onFrame: async () => { await holistic.send({image: video}); },
                width: 640, height: 480
            });
            camera.start();
            setTimeout(() => runStep(0), 2000);
        } catch (e) { alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼š" + e.message); }
    }

    // --- æµç¨‹æ§åˆ¶ ---
    function runStep(stepIndex) {
        currentStep = stepIndex;
        // ç»§æ‰¿åŸºå‡†
        const oldEyeBase = stats.baseEyeH;
        const oldLipBase = stats.baseLipH;
       Â 
        stats = {Â 
            blinks: 0, blinkStorms: 0,
            baseEyeH: oldEyeBase, baseLipH: oldLipBase,
            noseTouch: 0, chinTouch: 0, neckTouch: 0,
            lipCompress: 0, contemptFrames: 0,
            rubFrames: 0, steepFrames: 0,
            crossFrames: 0, ventralDenial: 0, freezeFrames: 0, shrugFrames: 0,
            shockFrames: 0, shockDuration: 0,
            frames: 0, lastEyeOpen: true, lastThumbPos: null, lastBlinkTime: 0, blinkBuffer: []
        };

        if (stepIndex === 0) {
            currentQ = { type: 'baseline', time: 8, text: POOL_BASE[0], id: 1 };
        } else if (stepIndex === 1) {
            currentQ = { type: 'baseline', time: 8, text: "å¥½çš„ã€‚" + POOL_BASE[1], id: 2 };
        } else if (stepIndex === 2) {
            if (!evidence.baseline) captureEvidence('baseline');
            evidence.frozenEyeBase = stats.baseEyeH;
            currentQ = { type: 'stress', time: 10, text: POOL_STRESS_1[0], id: 3 };
        } else if (stepIndex === 3) {
            const prevLog = sessionLog[2];
            if (prevLog && prevLog.score > 20) {
                currentQ = { type: 'trap', time: 10, text: POOL_TRAP[0], id: 4 };
            } else {
                currentQ = { type: 'stress', time: 10, text: POOL_STRESS_2[0], id: 4 };
            }
        } else if (stepIndex === 4) {
            const prevLog = sessionLog[3];
            if (prevLog.q.type === 'stress' && prevLog.score > 20) {
                currentQ = { type: 'trap', time: 10, text: "ã€æœ€ç»ˆè¿½é—®ã€‘ä½ çš„ç”Ÿç†ååº”éå¸¸å‰§çƒˆã€‚è¯·ç»™å‡ºä¸€ä¸ªåˆç†çš„è§£é‡Šã€‚", id: 5 };
            } else {
                generateReport(); return;
            }
        } else {
            generateReport(); return;
        }

        updateHUD();
        setTimeout(() => { finishQuestion(); runStep(stepIndex + 1); }, currentQ.time * 1000);
    }

    function updateHUD() {
        const badge = document.getElementById('hud_badge');
        let color = 'var(--accent)';
        if (currentQ.type === 'stress') color = 'var(--warn)';
        if (currentQ.type === 'trap') color = 'var(--danger)';

        badge.innerText = `${currentQ.type.toUpperCase()} PHASE`;
        badge.style.color = color;
        badge.style.borderColor = color;
        document.getElementById('hud_text').innerText = currentQ.text;
       Â 
        const bar = document.getElementById('hud_bar');
        bar.style.transition = 'none';Â 
        bar.style.width = '0%';
        bar.style.backgroundColor = color;
        bar.style.boxShadow = `0 0 15px ${color}`;
       Â 
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                bar.style.transition = `width ${currentQ.time}s linear`;Â 
                bar.style.width = '100%';Â 
            });
        });
    }

    function finishQuestion() {
        const cpm = Math.round(stats.blinks / (currentQ.time / 60));
        let score = 0;
       Â 
        if (currentQ.type !== 'baseline') {
            const baseLogs = sessionLog.filter(l => l.q.type === 'baseline');
            const baseCPM = baseLogs.length ? baseLogs[0].cpm : 20;
           Â 
            // è¯„åˆ†é€»è¾‘åŒ…å«æ‰€æœ‰æ–°ç‰¹å¾
            if (cpm > baseCPM * 1.4) score += 10;
            if (stats.blinkStorms > 0) score += 15; // çœ¨çœ¼é£æš´
           Â 
            if (stats.noseTouch > 5) score += 10;
            if (stats.neckTouch > 5) score += 10;
            if (stats.lipCompress > 10) score += 8;
            if (stats.contemptFrames > 10) score += 8; // è½»è”‘
           Â 
            if (stats.rubFrames > 20) score += 10;
            if (stats.steepFrames > 20) score -= 5; // å¡”å°–æ‰‹åŠ¿å‡åˆ†(è‡ªä¿¡)
           Â 
            if (stats.ventralDenial > 10) score += 10; // è…¹ä¾§å¦è®¤
            if (stats.freezeFrames > 20) score += 10; // å†»ç»“
            if (stats.shrugFrames > 10) score += 5;   // å‡è€¸è‚©
           Â 
            // çœŸå‡æƒŠè®¶åˆ¤å®š
            if (stats.shockFrames > 0) {
                if (stats.shockDuration > 30) score += 10; // å‡æƒŠè®¶ (>1s)
                else score += 5; // çœŸæƒŠè®¶
            }
        }
        sessionLog.push({ q: currentQ, stats: stats, cpm: cpm, score: score });
    }

    function captureEvidence(type) {
        const canvas = document.getElementById('main_canvas');
        if(canvas.width > 0) evidence[type] = canvas.toDataURL('image/jpeg', 0.8);
    }

    // --- AI æ ¸å¿ƒåˆ†æ (V27 Deep Logic) ---
    const canvas = document.getElementById('main_canvas');
    const ctx = canvas.getContext('2d');
    const sideCtx = {
        face: document.getElementById('cv_face').getContext('2d'),
        pose: document.getElementById('cv_pose').getContext('2d'),
        hands: document.getElementById('cv_hands').getContext('2d')
    };

    function onResults(results) {
        const video = document.getElementById('src_video');
        const vW = video.videoWidth; const vH = video.videoHeight;
       Â 
        if (vW && vH) {
            if (canvas.width !== vW || canvas.height !== vH) { canvas.width = vW; canvas.height = vH; }
            ctx.save(); ctx.clearRect(0, 0, vW, vH); ctx.drawImage(video, 0, 0, vW, vH);
        } else { return; }

        if (!results.faceLandmarks) { ctx.restore(); return; }

        const face = results.faceLandmarks;
        const noseTip = face[1];Â 
        const leftEyeH = Math.abs(face[159].y - face[145].y);
        const lipH = Math.abs(face[13].y - face[14].y);

        // åŸºå‡†
        if (currentQ && currentQ.type === 'baseline') {
            stats.baseEyeH = (stats.baseEyeH * stats.frames + leftEyeH) / (stats.frames + 1);
            stats.baseLipH = (stats.baseLipH * stats.frames + lipH) / (stats.frames + 1);
        }

        drawConnectors(ctx, face, FACEMESH_TESSELATION, {color: '#ffffff11', lineWidth: 0.5});

        let frameAnomaly = 0;

        // --- 1. çœ¼ç›é€»è¾‘ ---
        if (currentQ) {
            const isClosed = leftEyeH < 0.012;
           Â 
            // çœ¨çœ¼æ£€æµ‹
            if (isClosed && stats.lastEyeOpen) {
                stats.blinks++;
                const now = Date.now();
                // çœ¨çœ¼é£æš´ (500ms å†… > 3æ¬¡)
                stats.blinkBuffer.push(now);
                stats.blinkBuffer = stats.blinkBuffer.filter(t => now - t < 500);
                if (stats.blinkBuffer.length > 3) {
                    stats.blinkStorms++; frameAnomaly += 8;
                }
            }
            // è§†çº¿é˜»æ–­ (>1s)
            if (isClosed) {
                if(!stats.closeStart) stats.closeStart = Date.now();
                if(Date.now() - stats.closeStart > 1000) frameAnomaly += 5;
            } else { stats.closeStart = null; }
           Â 
            stats.lastEyeOpen = !isClosed;
        }

        // --- 2. å¾®è¡¨æƒ… ---
        // æƒŠè®¶ (å¯¹æ¯”é”å®šåŸºå‡†)
        if (currentQ && currentQ.type !== 'baseline' && evidence.frozenEyeBase > 0) {
            if (leftEyeH > evidence.frozenEyeBase * 1.4) {
                stats.shockFrames++;Â 
                stats.shockDuration++; // ç´¯è®¡æ—¶é•¿
                frameAnomaly += 5;
            } else {
                stats.shockDuration = 0; // é‡ç½®
            }
        }
       Â 
        // æŠ¿å˜´
        if (currentQ.type !== 'baseline' && stats.baseLipH > 0 && lipH < stats.baseLipH * 0.6) {
            stats.lipCompress++; frameAnomaly += 3;
        }

        // è½»è”‘ (Contempt) - å˜´è§’ä¸å¯¹ç§°
        const leftMouthY = face[61].y;
        const rightMouthY = face[291].y;
        if (Math.abs(leftMouthY - rightMouthY) > 0.02) { // é˜ˆå€¼éœ€è°ƒè¯•
            stats.contemptFrames++; frameAnomaly += 4;
        }

        // --- 3. æ‰‹éƒ¨é€»è¾‘ ---
        const checkHand = (hand, isLeft) => {
            if (!hand) return;
            const idx = hand[8]; const thumb = hand[4]; const wrist = hand[0];

            // æ‘¸é¼»
            if (Math.sqrt(Math.pow(idx.x - noseTip.x, 2) + Math.pow(idx.y - noseTip.y, 2)) < 0.05) {
                stats.noseTouch++; frameAnomaly += 8;
                ctx.beginPath(); ctx.arc(noseTip.x * vW, noseTip.y * vH, 20, 0, 2*Math.PI);
                ctx.strokeStyle = '#ff2a6d'; ctx.lineWidth = 3; ctx.stroke();
            }
            // æ‘¸è„–å­
            if (results.poseLandmarks) {
                const neckY = (results.poseLandmarks[11].y + results.poseLandmarks[12].y) / 2;
                if (Math.abs(wrist.y - neckY) < 0.1) {
                    stats.neckTouch++; frameAnomaly += 6;
                }
            }
            // æ“æ‰‹ (ç„¦è™‘)
            if (Math.sqrt(Math.pow(thumb.x - idx.x, 2) + Math.pow(thumb.y - idx.y, 2)) < 0.04) {
                if (stats.lastThumbPos) {
                    const move = Math.sqrt(Math.pow(thumb.x - stats.lastThumbPos.x, 2) + Math.pow(thumb.y - stats.lastThumbPos.y, 2));
                    if (move > 0.003) { stats.rubFrames++; frameAnomaly += 3; }
                }
                stats.lastThumbPos = {x: thumb.x, y: thumb.y};
            }
        };
        if (results.leftHandLandmarks) checkHand(results.leftHandLandmarks, true);
        if (results.rightHandLandmarks) checkHand(results.rightHandLandmarks, false);

        // å¡”å°–æ‰‹åŠ¿ (Steepling) - è‡ªä¿¡
        if (results.leftHandLandmarks && results.rightHandLandmarks) {
            const lIdx = results.leftHandLandmarks[8];
            const rIdx = results.rightHandLandmarks[8];
            const lWrist = results.leftHandLandmarks[0];
            const rWrist = results.rightHandLandmarks[0];
           Â 
            // æŒ‡å°–è¿‘ï¼Œæ‰‹è…•è¿œ
            const tipDist = Math.sqrt(Math.pow(lIdx.x - rIdx.x, 2) + Math.pow(lIdx.y - rIdx.y, 2));
            const wristDist = Math.sqrt(Math.pow(lWrist.x - rWrist.x, 2) + Math.pow(lWrist.y - rWrist.y, 2));
           Â 
            if (tipDist < 0.05 && wristDist > 0.15) {
                stats.steepFrames++; // è¿™æ˜¯ä¸€ä¸ªå‡åˆ†é¡¹(ä»£è¡¨è‡ªä¿¡)
            }
        }

        // --- 4. èº¯å¹²/æœ¬èƒ½ååº” ---
        if (results.poseLandmarks) {
            const pose = results.poseLandmarks;
            const lShldr = pose[11]; const rShldr = pose[12];
            const lEar = pose[7]; const rEar = pose[8];

            // è…¹ä¾§å¦è®¤ (Ventral Denial) - Zè½´å·®å¼‚
            if (Math.abs(lShldr.z - rShldr.z) > 0.3) {
                stats.ventralDenial++; frameAnomaly += 5;
            }

            // å†»ç»“/ä¹Œé¾Ÿæ•ˆåº” (Turtle Effect) - è€¸è‚©ç¼©è„–
            const shoulderEarDist = (Math.abs(lShldr.y - lEar.y) + Math.abs(rShldr.y - rEar.y)) / 2;
            // ç®€å•é€»è¾‘ï¼šå¦‚æœè·ç¦»æ˜¾è‘—å°äºå¹³æ—¶çš„åŸºå‡† (è¿™é‡Œç®€åŒ–ä¸ºé˜ˆå€¼)
            if (shoulderEarDist < 0.15) {Â 
                stats.freezeFrames++; frameAnomaly += 5;
            }

            // å‡è€¸è‚© (Asymmetric Shrug) - é«˜åº¦ä¸ä¸€
            if (Math.abs(lShldr.y - rShldr.y) > 0.05) {
                stats.shrugFrames++; frameAnomaly += 4;
            }
           Â 
            // æŠ±èƒ¸
            const lWrist = pose[15]; const rWrist = pose[16];
            if (lWrist.y > lShldr.y && Math.abs(lWrist.x - rWrist.x) < 0.2) {
                stats.crossFrames++; frameAnomaly += 4;
            }
        }

        // æ™ºèƒ½æŠ“æ‹
        if (currentQ && (currentQ.type === 'stress' || currentQ.type === 'trap')) {
            if (frameAnomaly > evidence.maxScore) {
                evidence.maxScore = frameAnomaly;
                captureEvidence('anomaly');
            }
        }

        ctx.restore();
        drawSide(sideCtx.face, results.faceLandmarks, FACEMESH_TESSELATION, '#00f2ff');
        drawSide(sideCtx.pose, results.poseLandmarks, POSE_CONNECTIONS, '#fff');
        drawSide(sideCtx.hands, results.leftHandLandmarks || results.rightHandLandmarks, HAND_CONNECTIONS, '#ff2a6d');

        if(currentQ) stats.frames++;
    }

    function drawSide(c, data, conn, color) {
        c.canvas.width=150; c.canvas.height=150; c.clearRect(0,0,150,150);
        if(data) { c.save(); drawConnectors(c, data, conn, {color: color, lineWidth: 2}); c.restore(); }
    }

    function generateReport() {
        document.getElementById('layer_report').classList.remove('hidden');
        const evArea = document.getElementById('evidence_area');
        const imgBase = evidence.baseline || "";
        const imgAnom = evidence.anomaly || imgBase;
        evArea.innerHTML = `
            <div class="photo-card">
                <img src="${imgBase}" class="photo-img">
                <div class="photo-meta" style="color:var(--accent)">åŸºå‡†çŠ¶æ€ (BASELINE)</div>
            </div>
            <div class="photo-card" style="border-color:var(--danger)">
                <img src="${imgAnom}" class="photo-img">
                <div class="photo-meta" style="color:var(--danger)">å‹åŠ›ååº” (REACTION)</div>
            </div>
        `;

        const logArea = document.getElementById('log_area');
        let html = "";
       Â 
        sessionLog.forEach(d => {
            let signals = [];
            if (d.q.type !== 'baseline') {
                const baseLogs = sessionLog.filter(l => l.q.type === 'baseline');
                const baseCPM = baseLogs.length ? baseLogs[0].cpm : 20;
               Â 
                if (d.cpm > baseCPM * 1.4) signals.push(`çœ¨çœ¼æ¿€å¢(${d.cpm})`);
                if (d.stats.blinkStorms > 0) signals.push("çœ¨çœ¼é£æš´");
               Â 
                if (d.stats.lipCompress > 15) signals.push("æŠ¿å˜´æ©é¥°");
                if (d.stats.contemptFrames > 10) signals.push("è½»è”‘è¡¨æƒ…");
               Â 
                if (d.stats.noseTouch > 5) signals.push("è§¦ç¢°é¼»å°–(æ©é¥°)");
                if (d.stats.neckTouch > 5) signals.push("è§¦ç¢°é¢ˆéƒ¨(ä¸å®‰)");
                if (d.stats.rubFrames > 20) signals.push("ç„¦è™‘æ“æ‰‹");
                if (d.stats.steepFrames > 10) signals.push("å¡”å°–æ‰‹åŠ¿(è‡ªä¿¡)"); // ç‰¹æ®Š
               Â 
                if (d.stats.ventralDenial > 10) signals.push("è…¹ä¾§å¦è®¤(é€ƒç¦»)");
                if (d.stats.freezeFrames > 20) signals.push("å†»ç»“ååº”");
                if (d.stats.shrugFrames > 10) signals.push("å‡è€¸è‚©");
               Â 
                if (d.stats.shockFrames > 0) {
                    if (d.stats.shockDuration > 30) signals.push("å‡æƒŠè®¶(è¡¨æ¼”)");
                    else signals.push("çœŸæƒŠè®¶");
                }
            }
            const isRisk = signals.length > 0;
            html += `
                <div class="log-item ${d.q.type}">
                    <div class="log-title">${d.q.type} PHASE</div>
                    <div style="font-size:16px; color:#fff; font-weight:700; margin-bottom:8px">"${d.q.text}"</div>
                    ${isRisk ? `<div style="color:#ff8a84; font-size:12px; font-weight:bold">âš  ${signals.join(", ")}</div>` : '<div style="font-size:12px; color:#aaa">ååº”å¹³ç¨³</div>'}
                </div>
            `;
        });
        logArea.innerHTML = html;
    }
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MindReader V27</title>
    <style>
        /* --- è§†è§‰ç³»ç»Ÿ (V26 ç¨³å®šç‰ˆ) --- */
        :root {
            --bg: #000000;
            --glass: rgba(20, 20, 20, 0.95);
            --border: rgba(255, 255, 255, 0.2);
            --accent: #00f2ff; 
            --warn: #ffcc00;
            --danger: #ff2a6d; 
            --text: #ffffff;
        }

        body {
            background: var(--bg); color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", monospace;
            margin: 0; height: 100dvh; display: flex; flex-direction: column; overflow: hidden;
        }

        .app { flex: 1; display: flex; flex-direction: column; position: relative; width: 100%; height: 100%; }

        /* HUD */
        .hud {
            /* ç‰©ç†å ä½ï¼Œé˜²æ­¢é®æŒ¡ */
            background: var(--glass); border-bottom: 1px solid var(--border);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px 20px 15px 20px; 
            z-index: 50; flex-shrink: 0; position: relative; backdrop-filter: blur(20px);
        }
        .phase-badge {
            font-size: 11px; font-weight: 800; letter-spacing: 2px; padding: 4px 8px;
            border-radius: 4px; margin-bottom: 10px; text-transform: uppercase; border: 1px solid currentColor;
        }
        .q-text { 
            font-size: 18px; font-weight: 700; text-align: center; line-height: 1.4; max-width: 600px;
            color: #ffffff !important; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 15px; 
        }
        
        /* è¿›åº¦æ¡ (ç‰©ç†é•¶åµŒ) */
        .progress-track {
            width: 100%; max-width: 300px; height: 6px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 3px; overflow: hidden;
        }
        .progress-fill {
            height: 100%; width: 0%; 
            background: var(--accent); 
            box-shadow: 0 0 15px currentColor;
            transition: width 0.1s linear; 
        }

        /* ç›‘æ§åŒº */
        .viewport {
            flex: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; overflow: hidden;
        }
        #main_canvas {
            width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1);
        }

        /* å¼¹çª—å·²ç‰©ç†åˆ é™¤ */

        /* åº•éƒ¨ä»ªè¡¨ç›˜ */
        .dashboard {
            height: 120px; background: var(--glass); border-top: 1px solid var(--border);
            display: flex; gap: 10px; padding: 15px; flex-shrink: 0; overflow-x: auto;
            backdrop-filter: blur(20px); padding-bottom: calc(15px + env(safe-area-inset-bottom));
        }
        .dash-card {
            flex: 1; min-width: 90px; background: rgba(255,255,255,0.05); border: 1px solid var(--border);
            border-radius: 8px; position: relative; overflow: hidden;
        }
        .dash-label { position: absolute; top: 5px; left: 5px; font-size: 9px; color: rgba(255,255,255,0.7); font-weight: 700; }
        .mini-canvas { width: 100%; height: 100%; opacity: 0.8; }

        /* å¯åŠ¨/æŠ¥å‘Šå±‚ */
        .layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 0.3s; padding: 30px; box-sizing: border-box;
        }
        .layer.hidden { opacity: 0; pointer-events: none; }

        .guide-box {
            background: #111; border: 1px solid #333; border-radius: 20px; padding: 30px;
            max-width: 400px; width: 100%; text-align: center;
        }
        .guide-item {
            display: flex; align-items: center; text-align: left; margin: 15px 0; font-size: 13px; color: #ccc;
            background: #222; padding: 15px; border-radius: 10px; border: 1px solid #333;
        }
        .guide-emoji { font-size: 24px; margin-right: 15px; width: 30px; text-align: center; }

        .btn-main {
            margin-top: 25px; width: 100%; padding: 18px 0; border-radius: 12px; border: none;
            background: linear-gradient(135deg, var(--accent), #0044ff); color: #ffffff !important;
            font-size: 16px; font-weight: 700; cursor: pointer; box-shadow: 0 4px 20px rgba(0, 242, 255, 0.3);
        }

        /* æŠ¥å‘Šé¡µ */
        .report-box { width: 100%; height: 100%; overflow-y: auto; padding: 20px; box-sizing: border-box; background: #050505; }
        .evidence-row { display: flex; gap: 10px; margin-bottom: 30px; margin-top: 10px; }
        .photo-card { flex: 1; background: #111; border: 1px solid #333; border-radius: 8px; overflow: hidden; }
        .photo-img { width: 100%; height: auto; display: block; border-bottom: 1px solid #333; }
        .photo-meta { padding: 10px; font-size: 10px; text-align: center; color: #aaa; text-transform: uppercase; font-weight: 700; }
        
        .log-item {
            background: #111; padding: 15px; border-radius: 10px; margin-bottom: 12px; border: 1px solid #333;
        }
        .log-item.stress { border-left: 4px solid var(--danger); }
        .log-item.trap { border-left: 4px solid var(--warn); }
        .log-item.baseline { border-left: 4px solid var(--accent); }

        .log-title { font-size: 10px; margin-bottom: 5px; text-transform: uppercase; font-weight: 700; }
        .log-item.baseline .log-title { color: var(--accent); }
        .log-item.stress .log-title { color: var(--warn); } 
        .log-item.trap .log-title { color: var(--danger); }

        #src_video { display: none; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>

<div class="layer" id="layer_start">
    <div class="guide-box">
        <h1 style="margin:0 0 10px 0; font-size: 26px; color:#fff;">MindReader <span style="font-size:16px; color:#666;">V27</span></h1>
        <p style="color:#888; font-size:13px; margin-bottom:30px">Deep Psychology Edition</p>
        
        <div class="guide-item">
            <div class="guide-emoji">ğŸ§ </div>
            <div>
                <div style="color:#fff; font-weight:700">æ·±åº¦ä¾§å†™</div>
                <div>å«è½»è”‘ã€çœŸå‡æƒŠè®¶ã€å¡”å°–æ‰‹åŠ¿ç­‰ 10+ ç§åˆ¤å®š</div>
            </div>
        </div>
        <div class="guide-item">
            <div class="guide-emoji">ğŸ”„</div>
            <div>
                <div style="color:#fff; font-weight:700">åŠ¨æ€åšå¼ˆ</div>
                <div>å¦‚æœæ£€æµ‹åˆ°å¼‚å¸¸ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨å‘èµ·è¿½é—®</div>
            </div>
        </div>
        <div class="guide-item">
            <div class="guide-emoji">ğŸ“</div>
            <div>
                <div style="color:#fff; font-weight:700">æ‘†æ”¾å»ºè®®</div>
                <div>è¯·å°†æ‰‹æœºæ”¾è¿œ (50cm+)ï¼Œç¡®ä¿ä¸ŠåŠèº«å…¥é•œ</div>
            </div>
        </div>

        <button class="btn-main" onclick="startSystem()">å¯åŠ¨åˆ†æ</button>
    </div>
</div>

<div class="app">
    <div class="hud" id="hud_box">
        <div class="phase-badge" id="hud_badge" style="color:var(--accent); border-color:var(--accent)">SYSTEM READY</div>
        <div class="q-text" id="hud_text">ä¼ æ„Ÿå™¨æ ¡å‡†ä¸­...</div>
        <div class="progress-track">
            <div class="progress-fill" id="hud_bar"></div>
        </div>
    </div>

    <div class="viewport">
        <canvas id="main_canvas"></canvas>
    </div>

    <div class="dashboard">
        <div class="dash-card"><div class="dash-label">FACE MESH</div><canvas id="cv_face" class="mini-canvas"></canvas></div>
        <div class="dash-card"><div class="dash-label">SKELETON</div><canvas id="cv_pose" class="mini-canvas"></canvas></div>
        <div class="dash-card"><div class="dash-label">HANDS</div><canvas id="cv_hands" class="mini-canvas"></canvas></div>
    </div>
</div>

<div class="layer hidden" id="layer_report">
    <div class="report-box">
        <h2 style="text-align:center; color:#fff; margin-bottom:30px">æœ€ç»ˆå¿ƒç†æ¡£æ¡ˆ</h2>
        
        <div style="font-size:11px; color:#888; font-weight:bold; letter-spacing:1px">å…³é”®è¯æ®å¿«ç…§ (EVIDENCE)</div>
        <div class="evidence-row" id="evidence_area"></div>

        <div style="font-size:11px; color:#888; font-weight:bold; letter-spacing:1px; margin-top:20px">åŠ¨æ€åˆ†ææµæ°´ (LOG)</div>
        <div id="log_area" style="margin-top:10px"></div>

        <button class="btn-main" style="width:100%; background:#222; margin-top:30px; border:1px solid #444" onclick="location.reload()">å½’æ¡£å¹¶é‡ç½®</button>
    </div>
</div>

<video id="src_video" playsinline></video>

<script>
    // --- é¢˜åº“ (æ´—ç‰Œ) ---
    const RAW_POOL_BASE = ["è¯·çœ‹ç€é•œå¤´ï¼Œç®€å•ä»‹ç»ä¸€ä¸‹ä½ çš„çˆ±å¥½ï¼Ÿ", "ä½ æœ€å–œæ¬¢çš„å­£èŠ‚æ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ", "ä½ å¹³æ—¶å‘¨æœ«ä¸€èˆ¬å‡ ç‚¹èµ·åºŠï¼Ÿ", "ä½ å…»è¿‡å® ç‰©å—ï¼Ÿ"];
    const RAW_POOL_STRESS_1 = ["ã€é«˜å‹ã€‘çœ‹ç€æˆ‘ã€‚ä½ æœ€è¿‘æ˜¯å¦å¯¹èº«è¾¹çš„äººæ’’è¿‡è°ï¼Ÿ", "ã€é«˜å‹ã€‘å¦‚æœæŸ¥ä½ çš„æ‰‹æœºç›¸å†Œï¼Œä¼šæœ‰ä¸æƒ³è®©äººçœ‹çš„ä¸œè¥¿å—ï¼Ÿ"];
    const RAW_POOL_STRESS_2 = ["ã€ä¸¤éš¾ã€‘å¦‚æœå¿…é¡»åœ¨äº‹ä¸šå’Œå®¶åº­ä¸­ç‰ºç‰²ä¸€ä¸ªï¼Œä½ é€‰å“ªä¸ªï¼Ÿ", "ã€å®¡è®¯ã€‘ä½ æ˜¯å¦æ›¾ç»èƒŒå›è¿‡æå…¶ä¿¡ä»»ä½ çš„äººï¼Ÿ"];
    const RAW_POOL_TRAP = ["ã€è¿½é—®ã€‘ä½ åœ¨æ’’è°å—ï¼Ÿä¸ºä»€ä¹ˆä½ åˆšæ‰çš„çœ¼ç¥åœ¨èº²é¿ï¼Ÿ", "ã€è¿½é—®ã€‘ä½ çš„èº«ä½“åŠ¨ä½œå‡ºå–äº†ä½ ï¼Œä½ åœ¨ç´§å¼ ä»€ä¹ˆï¼Ÿ"];

    let POOL_BASE = [], POOL_STRESS_1 = [], POOL_STRESS_2 = [], POOL_TRAP = [];

    function shuffle(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }

    let sessionLog = [];
    let currentStep = 0; 
    let currentQ = null;
    let evidence = { baseline: null, anomaly: null, maxScore: 0, frozenEyeBase: 0 };
    
    // --- æ‰©å±•ç»Ÿè®¡å˜é‡ (æ”¯æŒæ‰€æœ‰ 10 ç§é€»è¾‘) ---
    let stats = { 
        blinks: 0, blinkStorms: 0, // çœ¨çœ¼é£æš´
        baseEyeH: 0, baseLipH: 0, 
        
        noseTouch: 0, chinTouch: 0, neckTouch: 0,
        lipCompress: 0, 
        contemptFrames: 0, // è½»è”‘
        
        rubFrames: 0, steepFrames: 0, // æ“æ‰‹ï¼Œå¡”å°–
        
        crossFrames: 0, ventralDenial: 0, freezeFrames: 0, shrugFrames: 0, // å§¿æ€
        shockFrames: 0, shockDuration: 0, // çœŸå‡æƒŠè®¶
        
        frames: 0, lastEyeOpen: true, lastThumbPos: null, lastBlinkTime: 0, blinkBuffer: []
    };

    async function startSystem() {
        POOL_BASE = shuffle([...RAW_POOL_BASE]);
        POOL_STRESS_1 = shuffle([...RAW_POOL_STRESS_1]);
        POOL_STRESS_2 = shuffle([...RAW_POOL_STRESS_2]);
        POOL_TRAP = shuffle([...RAW_POOL_TRAP]);

        document.getElementById('layer_start').classList.add('hidden');
        const video = document.getElementById('src_video');
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: 640, height: 480, facingMode: "user" } 
            });
            video.srcObject = stream;
            await video.play();

            const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
            holistic.setOptions({modelComplexity: 1, minDetectionConfidence: 0.5, refineFaceLandmarks: true});
            holistic.onResults(onResults);
            
            const camera = new Camera(video, {
                onFrame: async () => { await holistic.send({image: video}); },
                width: 640, height: 480
            });
            camera.start();
            setTimeout(() => runStep(0), 2000);
        } catch (e) { alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼š" + e.message); }
    }

    // --- æµç¨‹æ§åˆ¶ ---
    function runStep(stepIndex) {
        currentStep = stepIndex;
        // ç»§æ‰¿åŸºå‡†
        const oldEyeBase = stats.baseEyeH;
        const oldLipBase = stats.baseLipH;
        
        stats = { 
            blinks: 0, blinkStorms: 0,
            baseEyeH: oldEyeBase, baseLipH: oldLipBase,
            noseTouch: 0, chinTouch: 0, neckTouch: 0,
            lipCompress: 0, contemptFrames: 0,
            rubFrames: 0, steepFrames: 0,
            crossFrames: 0, ventralDenial: 0, freezeFrames: 0, shrugFrames: 0,
            shockFrames: 0, shockDuration: 0,
            frames: 0, lastEyeOpen: true, lastThumbPos: null, lastBlinkTime: 0, blinkBuffer: []
        };

        if (stepIndex === 0) {
            currentQ = { type: 'baseline', time: 8, text: POOL_BASE[0], id: 1 };
        } else if (stepIndex === 1) {
            currentQ = { type: 'baseline', time: 8, text: "å¥½çš„ã€‚" + POOL_BASE[1], id: 2 };
        } else if (stepIndex === 2) {
            if (!evidence.baseline) captureEvidence('baseline');
            evidence.frozenEyeBase = stats.baseEyeH;
            currentQ = { type: 'stress', time: 10, text: POOL_STRESS_1[0], id: 3 };
        } else if (stepIndex === 3) {
            const prevLog = sessionLog[2];
            if (prevLog && prevLog.score > 20) {
                currentQ = { type: 'trap', time: 10, text: POOL_TRAP[0], id: 4 };
            } else {
                currentQ = { type: 'stress', time: 10, text: POOL_STRESS_2[0], id: 4 };
            }
        } else if (stepIndex === 4) {
            const prevLog = sessionLog[3];
            if (prevLog.q.type === 'stress' && prevLog.score > 20) {
                currentQ = { type: 'trap', time: 10, text: "ã€æœ€ç»ˆè¿½é—®ã€‘ä½ çš„ç”Ÿç†ååº”éå¸¸å‰§çƒˆã€‚è¯·ç»™å‡ºä¸€ä¸ªåˆç†çš„è§£é‡Šã€‚", id: 5 };
            } else {
                generateReport(); return;
            }
        } else {
            generateReport(); return;
        }

        updateHUD();
        setTimeout(() => { finishQuestion(); runStep(stepIndex + 1); }, currentQ.time * 1000);
    }

    function updateHUD() {
        const badge = document.getElementById('hud_badge');
        let color = 'var(--accent)';
        if (currentQ.type === 'stress') color = 'var(--warn)';
        if (currentQ.type === 'trap') color = 'var(--danger)';

        badge.innerText = `${currentQ.type.toUpperCase()} PHASE`;
        badge.style.color = color;
        badge.style.borderColor = color;
        document.getElementById('hud_text').innerText = currentQ.text;
        
        const bar = document.getElementById('hud_bar');
        bar.style.transition = 'none'; 
        bar.style.width = '0%';
        bar.style.backgroundColor = color;
        bar.style.boxShadow = `0 0 15px ${color}`;
        
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                bar.style.transition = `width ${currentQ.time}s linear`; 
                bar.style.width = '100%'; 
            });
        });
    }

    function finishQuestion() {
        const cpm = Math.round(stats.blinks / (currentQ.time / 60));
        let score = 0;
        
        if (currentQ.type !== 'baseline') {
            const baseLogs = sessionLog.filter(l => l.q.type === 'baseline');
            const baseCPM = baseLogs.length ? baseLogs[0].cpm : 20;
            
            // è¯„åˆ†é€»è¾‘åŒ…å«æ‰€æœ‰æ–°ç‰¹å¾
            if (cpm > baseCPM * 1.4) score += 10;
            if (stats.blinkStorms > 0) score += 15; // çœ¨çœ¼é£æš´
            
            if (stats.noseTouch > 5) score += 10;
            if (stats.neckTouch > 5) score += 10;
            if (stats.lipCompress > 10) score += 8;
            if (stats.contemptFrames > 10) score += 8; // è½»è”‘
            
            if (stats.rubFrames > 20) score += 10;
            if (stats.steepFrames > 20) score -= 5; // å¡”å°–æ‰‹åŠ¿å‡åˆ†(è‡ªä¿¡)
            
            if (stats.ventralDenial > 10) score += 10; // è…¹ä¾§å¦è®¤
            if (stats.freezeFrames > 20) score += 10; // å†»ç»“
            if (stats.shrugFrames > 10) score += 5;   // å‡è€¸è‚©
            
            // çœŸå‡æƒŠè®¶åˆ¤å®š
            if (stats.shockFrames > 0) {
                if (stats.shockDuration > 30) score += 10; // å‡æƒŠè®¶ (>1s)
                else score += 5; // çœŸæƒŠè®¶
            }
        }
        sessionLog.push({ q: currentQ, stats: stats, cpm: cpm, score: score });
    }

    function captureEvidence(type) {
        const canvas = document.getElementById('main_canvas');
        if(canvas.width > 0) evidence[type] = canvas.toDataURL('image/jpeg', 0.8);
    }

    // --- AI æ ¸å¿ƒåˆ†æ (V27 Deep Logic) ---
    const canvas = document.getElementById('main_canvas');
    const ctx = canvas.getContext('2d');
    const sideCtx = {
        face: document.getElementById('cv_face').getContext('2d'),
        pose: document.getElementById('cv_pose').getContext('2d'),
        hands: document.getElementById('cv_hands').getContext('2d')
    };

    function onResults(results) {
        const video = document.getElementById('src_video');
        const vW = video.videoWidth; const vH = video.videoHeight;
        
        if (vW && vH) {
            if (canvas.width !== vW || canvas.height !== vH) { canvas.width = vW; canvas.height = vH; }
            ctx.save(); ctx.clearRect(0, 0, vW, vH); ctx.drawImage(video, 0, 0, vW, vH);
        } else { return; }

        if (!results.faceLandmarks) { ctx.restore(); return; }

        const face = results.faceLandmarks;
        const noseTip = face[1]; 
        const leftEyeH = Math.abs(face[159].y - face[145].y);
        const lipH = Math.abs(face[13].y - face[14].y);

        // åŸºå‡†
        if (currentQ && currentQ.type === 'baseline') {
            stats.baseEyeH = (stats.baseEyeH * stats.frames + leftEyeH) / (stats.frames + 1);
            stats.baseLipH = (stats.baseLipH * stats.frames + lipH) / (stats.frames + 1);
        }

        drawConnectors(ctx, face, FACEMESH_TESSELATION, {color: '#ffffff11', lineWidth: 0.5});

        let frameAnomaly = 0;

        // --- 1. çœ¼ç›é€»è¾‘ ---
        if (currentQ) {
            const isClosed = leftEyeH < 0.012;
            
            // çœ¨çœ¼æ£€æµ‹
            if (isClosed && stats.lastEyeOpen) {
                stats.blinks++;
                const now = Date.now();
                // çœ¨çœ¼é£æš´ (500ms å†… > 3æ¬¡)
                stats.blinkBuffer.push(now);
                stats.blinkBuffer = stats.blinkBuffer.filter(t => now - t < 500);
                if (stats.blinkBuffer.length > 3) {
                    stats.blinkStorms++; frameAnomaly += 8;
                }
            }
            // è§†çº¿é˜»æ–­ (>1s)
            if (isClosed) {
                if(!stats.closeStart) stats.closeStart = Date.now();
                if(Date.now() - stats.closeStart > 1000) frameAnomaly += 5;
            } else { stats.closeStart = null; }
            
            stats.lastEyeOpen = !isClosed;
        }

        // --- 2. å¾®è¡¨æƒ… ---
        // æƒŠè®¶ (å¯¹æ¯”é”å®šåŸºå‡†)
        if (currentQ && currentQ.type !== 'baseline' && evidence.frozenEyeBase > 0) {
            if (leftEyeH > evidence.frozenEyeBase * 1.4) {
                stats.shockFrames++; 
                stats.shockDuration++; // ç´¯è®¡æ—¶é•¿
                frameAnomaly += 5;
            } else {
                stats.shockDuration = 0; // é‡ç½®
            }
        }
        
        // æŠ¿å˜´
        if (currentQ.type !== 'baseline' && stats.baseLipH > 0 && lipH < stats.baseLipH * 0.6) {
            stats.lipCompress++; frameAnomaly += 3;
        }

        // è½»è”‘ (Contempt) - å˜´è§’ä¸å¯¹ç§°
        const leftMouthY = face[61].y;
        const rightMouthY = face[291].y;
        if (Math.abs(leftMouthY - rightMouthY) > 0.02) { // é˜ˆå€¼éœ€è°ƒè¯•
            stats.contemptFrames++; frameAnomaly += 4;
        }

        // --- 3. æ‰‹éƒ¨é€»è¾‘ ---
        const checkHand = (hand, isLeft) => {
            if (!hand) return;
            const idx = hand[8]; const thumb = hand[4]; const wrist = hand[0];

            // æ‘¸é¼»
            if (Math.sqrt(Math.pow(idx.x - noseTip.x, 2) + Math.pow(idx.y - noseTip.y, 2)) < 0.05) {
                stats.noseTouch++; frameAnomaly += 8;
                ctx.beginPath(); ctx.arc(noseTip.x * vW, noseTip.y * vH, 20, 0, 2*Math.PI);
                ctx.strokeStyle = '#ff2a6d'; ctx.lineWidth = 3; ctx.stroke();
            }
            // æ‘¸è„–å­
            if (results.poseLandmarks) {
                const neckY = (results.poseLandmarks[11].y + results.poseLandmarks[12].y) / 2;
                if (Math.abs(wrist.y - neckY) < 0.1) {
                    stats.neckTouch++; frameAnomaly += 6;
                }
            }
            // æ“æ‰‹ (ç„¦è™‘)
            if (Math.sqrt(Math.pow(thumb.x - idx.x, 2) + Math.pow(thumb.y - idx.y, 2)) < 0.04) {
                if (stats.lastThumbPos) {
                    const move = Math.sqrt(Math.pow(thumb.x - stats.lastThumbPos.x, 2) + Math.pow(thumb.y - stats.lastThumbPos.y, 2));
                    if (move > 0.003) { stats.rubFrames++; frameAnomaly += 3; }
                }
                stats.lastThumbPos = {x: thumb.x, y: thumb.y};
            }
        };
        if (results.leftHandLandmarks) checkHand(results.leftHandLandmarks, true);
        if (results.rightHandLandmarks) checkHand(results.rightHandLandmarks, false);

        // å¡”å°–æ‰‹åŠ¿ (Steepling) - è‡ªä¿¡
        if (results.leftHandLandmarks && results.rightHandLandmarks) {
            const lIdx = results.leftHandLandmarks[8];
            const rIdx = results.rightHandLandmarks[8];
            const lWrist = results.leftHandLandmarks[0];
            const rWrist = results.rightHandLandmarks[0];
            
            // æŒ‡å°–è¿‘ï¼Œæ‰‹è…•è¿œ
            const tipDist = Math.sqrt(Math.pow(lIdx.x - rIdx.x, 2) + Math.pow(lIdx.y - rIdx.y, 2));
            const wristDist = Math.sqrt(Math.pow(lWrist.x - rWrist.x, 2) + Math.pow(lWrist.y - rWrist.y, 2));
            
            if (tipDist < 0.05 && wristDist > 0.15) {
                stats.steepFrames++; // è¿™æ˜¯ä¸€ä¸ªå‡åˆ†é¡¹(ä»£è¡¨è‡ªä¿¡)
            }
        }

        // --- 4. èº¯å¹²/æœ¬èƒ½ååº” ---
        if (results.poseLandmarks) {
            const pose = results.poseLandmarks;
            const lShldr = pose[11]; const rShldr = pose[12];
            const lEar = pose[7]; const rEar = pose[8];

            // è…¹ä¾§å¦è®¤ (Ventral Denial) - Zè½´å·®å¼‚
            if (Math.abs(lShldr.z - rShldr.z) > 0.3) {
                stats.ventralDenial++; frameAnomaly += 5;
            }

            // å†»ç»“/ä¹Œé¾Ÿæ•ˆåº” (Turtle Effect) - è€¸è‚©ç¼©è„–
            const shoulderEarDist = (Math.abs(lShldr.y - lEar.y) + Math.abs(rShldr.y - rEar.y)) / 2;
            // ç®€å•é€»è¾‘ï¼šå¦‚æœè·ç¦»æ˜¾è‘—å°äºå¹³æ—¶çš„åŸºå‡† (è¿™é‡Œç®€åŒ–ä¸ºé˜ˆå€¼)
            if (shoulderEarDist < 0.15) { 
                stats.freezeFrames++; frameAnomaly += 5;
            }

            // å‡è€¸è‚© (Asymmetric Shrug) - é«˜åº¦ä¸ä¸€
            if (Math.abs(lShldr.y - rShldr.y) > 0.05) {
                stats.shrugFrames++; frameAnomaly += 4;
            }
            
            // æŠ±èƒ¸
            const lWrist = pose[15]; const rWrist = pose[16];
            if (lWrist.y > lShldr.y && Math.abs(lWrist.x - rWrist.x) < 0.2) {
                stats.crossFrames++; frameAnomaly += 4;
            }
        }

        // æ™ºèƒ½æŠ“æ‹
        if (currentQ && (currentQ.type === 'stress' || currentQ.type === 'trap')) {
            if (frameAnomaly > evidence.maxScore) {
                evidence.maxScore = frameAnomaly;
                captureEvidence('anomaly');
            }
        }

        ctx.restore();
        drawSide(sideCtx.face, results.faceLandmarks, FACEMESH_TESSELATION, '#00f2ff');
        drawSide(sideCtx.pose, results.poseLandmarks, POSE_CONNECTIONS, '#fff');
        drawSide(sideCtx.hands, results.leftHandLandmarks || results.rightHandLandmarks, HAND_CONNECTIONS, '#ff2a6d');

        if(currentQ) stats.frames++;
    }

    function drawSide(c, data, conn, color) {
        c.canvas.width=150; c.canvas.height=150; c.clearRect(0,0,150,150);
        if(data) { c.save(); drawConnectors(c, data, conn, {color: color, lineWidth: 2}); c.restore(); }
    }

    function generateReport() {
        document.getElementById('layer_report').classList.remove('hidden');
        const evArea = document.getElementById('evidence_area');
        const imgBase = evidence.baseline || "";
        const imgAnom = evidence.anomaly || imgBase;
        evArea.innerHTML = `
            <div class="photo-card">
                <img src="${imgBase}" class="photo-img">
                <div class="photo-meta" style="color:var(--accent)">åŸºå‡†çŠ¶æ€ (BASELINE)</div>
            </div>
            <div class="photo-card" style="border-color:var(--danger)">
                <img src="${imgAnom}" class="photo-img">
                <div class="photo-meta" style="color:var(--danger)">å‹åŠ›ååº” (REACTION)</div>
            </div>
        `;

        const logArea = document.getElementById('log_area');
        let html = "";
        
        sessionLog.forEach(d => {
            let signals = [];
            if (d.q.type !== 'baseline') {
                const baseLogs = sessionLog.filter(l => l.q.type === 'baseline');
                const baseCPM = baseLogs.length ? baseLogs[0].cpm : 20;
                
                if (d.cpm > baseCPM * 1.4) signals.push(`çœ¨çœ¼æ¿€å¢(${d.cpm})`);
                if (d.stats.blinkStorms > 0) signals.push("çœ¨çœ¼é£æš´");
                
                if (d.stats.lipCompress > 15) signals.push("æŠ¿å˜´æ©é¥°");
                if (d.stats.contemptFrames > 10) signals.push("è½»è”‘è¡¨æƒ…");
                
                if (d.stats.noseTouch > 5) signals.push("è§¦ç¢°é¼»å°–(æ©é¥°)");
                if (d.stats.neckTouch > 5) signals.push("è§¦ç¢°é¢ˆéƒ¨(ä¸å®‰)");
                if (d.stats.rubFrames > 20) signals.push("ç„¦è™‘æ“æ‰‹");
                if (d.stats.steepFrames > 10) signals.push("å¡”å°–æ‰‹åŠ¿(è‡ªä¿¡)"); // ç‰¹æ®Š
                
                if (d.stats.ventralDenial > 10) signals.push("è…¹ä¾§å¦è®¤(é€ƒç¦»)");
                if (d.stats.freezeFrames > 20) signals.push("å†»ç»“ååº”");
                if (d.stats.shrugFrames > 10) signals.push("å‡è€¸è‚©");
                
                if (d.stats.shockFrames > 0) {
                    if (d.stats.shockDuration > 30) signals.push("å‡æƒŠè®¶(è¡¨æ¼”)");
                    else signals.push("çœŸæƒŠè®¶");
                }
            }
            const isRisk = signals.length > 0;
            html += `
                <div class="log-item ${d.q.type}">
                    <div class="log-title">${d.q.type} PHASE</div>
                    <div style="font-size:16px; color:#fff; font-weight:700; margin-bottom:8px">"${d.q.text}"</div>
                    ${isRisk ? `<div style="color:#ff8a84; font-size:12px; font-weight:bold">âš  ${signals.join(", ")}</div>` : '<div style="font-size:12px; color:#aaa">ååº”å¹³ç¨³</div>'}
                </div>
            `;
        });
        logArea.innerHTML = html;
    }
</script>
</body>
</html>
