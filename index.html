<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>MindReader V12 - Fixed</title>
    <style>
        /* --- 1. æ ¸å¿ƒä¿®å¤æ ·å¼ --- */
        :root {
            --bg-color: #050505;
            --card-bg: rgba(30, 30, 30, 0.6);
            --accent: #00f2ff;
        }

        body {
            background: var(--bg-color);
            color: #fff;
            font-family: -apple-system, sans-serif;
            margin: 0;
            height: 100vh; /* å¼ºåˆ¶è§†å£é«˜åº¦ */
            height: 100dvh; /* åŠ¨æ€é«˜åº¦é€‚é… iOS */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* ç¦æ­¢é¡µé¢æ»šåŠ¨ */
        }

        /* --- å¸ƒå±€å®¹å™¨ --- */
        .app-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* 1. é¡¶éƒ¨ HUD (å›ºå®šé«˜åº¦) */
        .top-hud {
            height: 70px;
            background: rgba(0,0,0,0.8);
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between; /* ä¸¤ç«¯å¯¹é½ */
            align-items: center;
            padding: 0 20px;
            z-index: 50;
            flex-shrink: 0; /* ç¦æ­¢è¢«å‹ç¼© */
        }
        
        .hud-info { display: flex; flex-direction: column; }
        .status-dot { width: 8px; height: 8px; background: #0f0; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-text { font-size: 10px; color: #888; }
        .result-text { font-size: 16px; font-weight: bold; color: #fff; }

        /* ç›¸æœºåˆ‡æ¢å°æŒ‰é’® */
        .cam-switch {
            background: #333; border: 1px solid #555; color: #fff;
            padding: 5px 10px; border-radius: 5px; font-size: 10px;
        }

        /* 2. ä¸­é—´ä¸»èˆå° (è‡ªé€‚åº”é«˜åº¦) */
        .stage {
            flex: 1; /* å æ®å‰©ä½™æ‰€æœ‰ç©ºé—´ */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background: #000;
        }

        /* ä¿®å¤ï¼šç”»å¸ƒè‡ªé€‚åº”ï¼Œä¿æŒæ¯”ä¾‹ï¼Œä¸è¶…å‡ºå±å¹• */
        #output_canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* 3. åº•éƒ¨ä¾§è¾¹æ  (å›ºå®šé«˜åº¦ï¼Œä¿®å¤æ˜¾ç¤ºä¸å…¨) */
        .sidebar {
            height: 110px; /* å›ºå®šé«˜åº¦ */
            background: #111;
            border-top: 1px solid #333;
            display: flex;
            flex-direction: row;
            padding: 10px;
            gap: 10px;
            flex-shrink: 0; /* å…³é”®ï¼šç¦æ­¢è¢«æŒ¤å‹ */
            overflow-x: auto; /* å…è®¸æ¨ªå‘æ»šåŠ¨ */
            z-index: 40;
            padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* é€‚é… iPhone é»‘æ¡ */
        }

        .preview-card {
            flex: 1;
            background: #222;
            border-radius: 8px;
            border: 1px solid #444;
            position: relative;
            min-width: 80px; /* é˜²æ­¢å¤ªçª„ */
        }
        
        .card-label { position: absolute; top: 2px; left: 4px; font-size: 8px; color: #aaa; }
        .side-canvas { width: 100%; height: 100%; }

        /* 4. æ‚¬æµ®æŒ‰é’® (FAB) */
        .fab-btn {
            position: absolute;
            bottom: 130px; /* ä½äºä¾§è¾¹æ ä¸Šæ–¹ */
            right: 20px;
            width: 56px; height: 56px;
            border-radius: 50%;
            background: var(--accent);
            border: none;
            box-shadow: 0 4px 15px rgba(0, 242, 255, 0.4);
            z-index: 100;
            display: flex; justify-content: center; align-items: center;
        }
        
        /* éšè—å…ƒç´ ä½†ä¿ç•™æ¸²æŸ“èƒ½åŠ› (ä¿®å¤ iOS Bug) */
        .hidden-source {
            position: absolute;
            top: 0; left: 0;
            width: 1px; height: 1px;
            opacity: 0;
            pointer-events: none;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
</head>
<body>

<div class="app-container">
    <div class="top-hud">
        <div class="hud-info">
            <div class="status-row"><span class="status-dot" id="dot"></span><span class="status-text" id="status">ç³»ç»Ÿå°±ç»ª</span></div>
            <div class="result-text" id="result">ç­‰å¾…è¾“å…¥</div>
        </div>
        <button class="cam-switch" onclick="toggleCamera()">åˆ‡æ¢ç›¸æœº</button>
    </div>

    <div class="stage">
        <canvas id="output_canvas"></canvas>
    </div>

    <div class="sidebar">
        <div class="preview-card"><span class="card-label">FACE</span><canvas id="cv_face" class="side-canvas"></canvas></div>
        <div class="preview-card"><span class="card-label">POSE</span><canvas id="cv_pose" class="side-canvas"></canvas></div>
        <div class="preview-card"><span class="card-label">HANDS</span><canvas id="cv_hands" class="side-canvas"></canvas></div>
    </div>
</div>

<video id="src_video" class="hidden-source" playsinline></video>
<img id="src_img" class="hidden-source">

<input type="file" id="file_input" accept="image/*" style="display: none;">
<button class="fab-btn" onclick="document.getElementById('file_input').click()">
    ğŸ“·
</button>

<script>
    // 1. ç»‘å®šå…ƒç´ 
    const video = document.getElementById('src_video');
    const img = document.getElementById('src_img');
    const canvas = document.getElementById('output_canvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('status');
    const resultText = document.getElementById('result');
    const dot = document.getElementById('dot');
    
    const sideCtx = {
        face: document.getElementById('cv_face').getContext('2d'),
        pose: document.getElementById('cv_pose').getContext('2d'),
        hands: document.getElementById('cv_hands').getContext('2d')
    };

    let cameraObj = null;
    let isCameraMode = false;

    // 2. æ ¸å¿ƒåˆ†æ
    function onResults(results) {
        statusText.innerText = "åˆ†æå®Œæˆ";
        
        // åŠ¨æ€è°ƒæ•´ç”»å¸ƒå°ºå¯¸
        const width = isCameraMode ? video.videoWidth : img.naturalWidth;
        const height = isCameraMode ? video.videoHeight : img.naturalHeight;
        
        if (width > 0 && height > 0) {
            canvas.width = width;
            canvas.height = height;
            
            ctx.save();
            ctx.clearRect(0, 0, width, height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            if (isCameraMode) {
                ctx.drawImage(video, 0, 0, width, height);
            } else {
                ctx.drawImage(img, 0, 0, width, height);
            }

            // ç»˜åˆ¶éª¨æ¶ (æ›´æ¸…æ™°çš„é…è‰²)
            drawConnectors(ctx, results.faceLandmarks, FACEMESH_TESSELATION, {color: '#00ffff22', lineWidth: 1});
            drawConnectors(ctx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#ffff00', lineWidth: 2});
            drawConnectors(ctx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#ff00ff', lineWidth: 2});
            drawConnectors(ctx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#ff00ff', lineWidth: 2});
            ctx.restore();

            // ä¾§è¾¹æ 
            drawSide(sideCtx.face, results.faceLandmarks, FACEMESH_TESSELATION, '#0ff');
            drawSide(sideCtx.pose, results.poseLandmarks, POSE_CONNECTIONS, '#ff0');
            drawSide(sideCtx.hands, results.leftHandLandmarks || results.rightHandLandmarks, HAND_CONNECTIONS, '#f0f');

            // é€»è¾‘åˆ¤æ–­
            analyze(results);
        }
    }

    function analyze(results) {
        if (results.faceLandmarks) {
            const mouth = results.faceLandmarks[13];
            let cover = false;
            const check = (hand) => {
                if(!hand) return false;
                return Math.sqrt(Math.pow(mouth.x - hand[8].x, 2) + Math.pow(mouth.y - hand[8].y, 2)) < 0.15;
            };
            if(check(results.leftHandLandmarks) || check(results.rightHandLandmarks)) cover = true;

            if(cover) {
                resultText.innerText = "âš ï¸ æ£€æµ‹åˆ°é®æŒ¡ (æ©é¥°)";
                resultText.style.color = "#ff3366";
            } else {
                resultText.innerText = "çŠ¶æ€æ­£å¸¸";
                resultText.style.color = "#fff";
            }
        } else {
            resultText.innerText = "æœªæ£€æµ‹åˆ°äººè„¸";
            resultText.style.color = "#aaa";
        }
    }

    function drawSide(c, data, conn, color) {
        c.canvas.width = 200; c.canvas.height = 200;
        c.clearRect(0,0,200,200);
        if(data) {
            drawConnectors(c, data, conn, {color: color, lineWidth: 2});
        }
    }

    // 3. åˆå§‹åŒ– AI
    const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
    holistic.setOptions({modelComplexity: 1, minDetectionConfidence: 0.5});
    holistic.onResults(onResults);

    // 4. å›¾ç‰‡ä¸Šä¼ å¤„ç† (ä¿®å¤ç‰ˆ)
    document.getElementById('file_input').onchange = (e) => {
        const file = e.target.files[0];
        if(!file) return;
        
        isCameraMode = false;
        if(cameraObj) cameraObj.stop(); // åœæ­¢ç›¸æœº

        statusText.innerText = "æ­£åœ¨å¤„ç†å›¾ç‰‡...";
        
        const reader = new FileReader();
        reader.onload = (evt) => {
            img.src = evt.target.result;
            // ç­‰å¾…å›¾ç‰‡è§£ç å®Œæˆ
            img.onload = async () => {
                await holistic.send({image: img});
            }
        };
        reader.readAsDataURL(file);
    };

    // 5. ç›¸æœºåˆ‡æ¢é€»è¾‘
    window.toggleCamera = async function() {
        isCameraMode = !isCameraMode;
        if (isCameraMode) {
            statusText.innerText = "å¯åŠ¨ç›¸æœºä¸­...";
            if (!cameraObj) {
                cameraObj = new Camera(video, {
                    onFrame: async () => { await holistic.send({image: video}); },
                    width: 640, height: 480
                });
            }
            try {
                await cameraObj.start();
                statusText.innerText = "ç›¸æœºè¿è¡Œä¸­";
            } catch(e) {
                alert("æ— æ³•å¯åŠ¨ç›¸æœºï¼Œè¯·æ£€æŸ¥æƒé™æˆ–ä½¿ç”¨HTTPS");
                isCameraMode = false;
            }
        } else {
            if(cameraObj) cameraObj.stop();
            statusText.innerText = "å·²åˆ‡æ¢å›å›¾ç‰‡æ¨¡å¼";
        }
    }
</script>
</body>
</html>

